from typing import Any
from dask.task_spec import DataNode, Task, Alias
from dask.typing import Key
from distributed.scheduler import TaskState

import prov.model as prov
from prov_tracking.utils import RunnableTaskInfo, GeneratedValue, ReadyValue

def _sanitize(string: str):
  return string.replace('(', '').replace(')', '').replace('\'', '').replace(', ', '_')
  return string

def _serialize_value(obj):
  if isinstance(obj, str):
    return obj
  elif isinstance(obj, (list, tuple)):
    tmp_list = [ _serialize_value(x) for x in obj ]
    if isinstance(obj, tuple):
      return str(tuple(tmp_list))
    else:
      return str(tmp_list)
  elif isinstance(obj, dict):
    return str({ k: _serialize_value(v) for k, v in obj.items() })
  else:
    return str(obj)

def _type(obj) -> str:
  if isinstance(obj, list):
    if len(obj) == 0:
      return 'list[()]'
    else:
      return f'list[{_type(obj[0])}]'
  if isinstance(obj, tuple):
    if len(obj) == 0:
      return 'tuple[()]'
    else:
      types = []
      for item in obj:
        types.append(_type(item))
      return f'tuple[{', '.join(types)}]'
  if not isinstance(obj, type):
    obj = type(obj)
  module = obj.__module__
  if module != 'builtins':
    return f'{module}.{obj.__qualname__}'
  else:
    return obj.__qualname__
    

class Documenter:
  def __init__(self, **kwargs):
    self.document = prov.ProvDocument()
    self.document.set_default_namespace('dask-prov.dict')
    self.format = kwargs.pop('format', 'json')
    self.destination = kwargs.pop('destination', './provenance.json')
    self.rich_types: bool = kwargs.pop('rich_types', False)
    self.kwargs: dict[str, Any] = kwargs

  def register_non_runnable_task(self, task_id: Key, task: DataNode):
    """Non-runnable tasks are registered as entity as they are in fact just data"""

    key = _sanitize(str(task_id))
    self.document.entity(
      identifier=task_id,
      other_attributes={
        'value': _serialize_value(task.value),
        'dtype': str(type(task.typ)) if not self.rich_types else _type(task.typ)
      }
    )

  def register_runnable_task(self, info: RunnableTaskInfo) -> str:
    """Runnble tasks are registered as activities. Parameters to the task are
    registered as entities linked to the activity via used relations. All
    runnable dependencies of the task are registered via communication relations."""

    activity_id = _sanitize(str(info.key))
    attributes = {
      'name': str(info.func),
      'module': info.func.__module__,
      'group': info.group,
    }
    if hasattr(info.func, '__name__'):
      attributes['nice_name'] = info.func.__name__

    self.document.activity(
      identifier=activity_id,
      startTime=info.start_time,
      endTime=info.finish_time,
      other_attributes=attributes
    )

    # Records the used parameters
    used_params = []
    for name, param in info.args_dict.items():
      if isinstance(param, ReadyValue):
        key = f'{activity_id}.{name}'
        self.document.entity(
          identifier=key,
          other_attributes={
            'value': _serialize_value(param.value),
            'dtype': str(type(param.value)) if not self.rich_types else _type(param.value)
          }
        )
        used_params.append((name, key))
      else:
        key = f'{_sanitize(param.generatedBy)}.return_value'
        used_params.append((name, key))
    for name, key in used_params:
      self.document.used(
        activity=activity_id,
        entity=key,
        time=info.start_time,
        other_attributes={
          'as_parameter': name
        }
      )
    
    # Register all dependencies of this task
    for dep in info.dependencies:
      key = _sanitize(str(dep))
      self.document.wasInformedBy(informed=activity_id, informant=key)

    for dep in info.other_dependencies:
      key = _sanitize(str(dep))
      self.document.used(
        entity=key,
        activity=activity_id,
        time=info.start_time
      )

    return activity_id

  def register_successful_task(
    self, info: RunnableTaskInfo, dtype: type, nbytes: int
  ):
    """Registers the successful completion of a runnble task that has produced
    some value"""

    activity_id = self.register_runnable_task(info)

    # Records the value generated by this funcion
    key = f'{activity_id}.return_value'
    self.document.entity(
      identifier=key,
      other_attributes={
        'dtype': dtype,
        'nbytes': str(nbytes)
      }
    )
    self.document.wasGeneratedBy(
      entity=key,
      activity=activity_id,
      time=info.finish_time
    )

  def register_failed_task(
    self, info: RunnableTaskInfo, exception_text: str, traceback: str | None,
    blamed_task: TaskState | None
  ):
    """Registers the failed completion of a runnble task that has terminated
    with an exception"""

    activity_id = self.register_runnable_task(info)
    key = f'{activity_id}.return_value'
    attributes = {
      'is_error': True,
      'exception_text': exception_text,
    }
    if traceback is not None:
      attributes['traceback'] = traceback
    if blamed_task is not None and blamed_task.key != activity_id:
      other_task_id = _sanitize(str(blamed_task.key))
      attributes['blamed_task'] = other_task_id
      self.document.wasInformedBy(informed=activity_id, informant=other_task_id)

    self.document.entity(
      identifier=key,
      other_attributes=attributes
    )
    self.document.wasGeneratedBy(
      entity=key, activity=activity_id, time=info.finish_time
    )

  def register_alias(self, task: TaskState, target_task: TaskState):
    task_id = _sanitize(str(task.key))
    target_id = _sanitize(str(target_task.key))
    self.document.activity(
      identifier=task_id,
    )
    self.document.wasInformedBy(
      informed=task_id,
      informant=target_id
    )

  def serialize(self, destination=None, format=None, **kwargs: dict[str, Any]):
    """
    Serializes the provenance document into `destination`, or returns the
    serialized string if no destination was provided. The format used is `format`,
    or the default format provided on initialization if the parameter here is
    `None`.
    """

    if format is None and self.format is not None:
      format = self.format
    if destination is None and self.destination is not None:
      destination = self.destination
    if len(kwargs) == 0:
      kwargs = self.kwargs

    return self.document.serialize(
      destination=destination, format=format, **kwargs
    )
