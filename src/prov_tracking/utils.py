from uuid import uuid4
from dask.task_spec import Task, DataNode, Alias, TaskRef, List
from dask.typing import Key
from typing import Any

class RawValue:
  """A value already available and is not associated to a `DataNode`, e.g. an
  integer value o a string."""
  def __init__(self, value: Any):
    self.value = value

  def __eq__(self, o: object) -> bool:
    if isinstance(o, RawValue):
      return self.value == o.value
    return False
  
  def __hash__(self) -> int:
    return hash(('value', repr(self.value)))

class ReadyValue:
  """A value already available, but that is associated to a `DataNode`, i.e. the
  `value` attribute of a `DataNode` object."""

  def __init__(self, key: str, value: Any):
    self.key = key
    self.value = value

  def __eq__(self, o: object) -> bool:
    if isinstance(o, ReadyValue):
      return self.value == o.value and self.key == o.key
    return False
  
  def __hash__(self) -> int:
    return hash(('key', self.key, 'value', repr(self.value)))

class GeneratedValue:
  """A value which has been generated by another task."""

  def __init__(self, generator: str):
    self.generatedBy = generator

  def __eq__(self, o: object) -> bool:
    if isinstance(o, GeneratedValue):
      return self.generatedBy == o.generatedBy
    return False

  def __hash__(self) -> int:
    return hash(('generatedBy', self.generatedBy))

type Value = GeneratedValue | ReadyValue | RawValue

def get_value(
  obj: Any, all_tasks: dict[Key, Task | DataNode],
  dependencies: dict[Key, Task | DataNode | Alias | Any],
  unique_keys: dict[Key, Key],
  pending_tasks: list[tuple[Key, Task]],
  refkey: Key
) -> Value:
  """Given a parameter value creates a suitable representation for it. If the
  value comes from another task, returns a `GeneratedValue`, otherwise returns
  a `ReadyValue`.
  
  It might happen that a value references a task that doesn't exist in the
  system. In that case a new task is created and is put into `pending_tasks`.
  The key created for the task is unique and used `refkey` as parent key. The
  newly created tasks will have to be registered with both the plugin and the
  provenance document."""

  if isinstance(obj, TaskRef):
    task = None
    if obj.key in dependencies:
      task = dependencies[obj.key]
    else:
      key = unique_keys.get(obj.key, obj.key)
      task = all_tasks[key]
    if hasattr(task, 'key'):# and task.key not in all_tasks:
      unique_obj_key = unique_keys.get(obj.key, obj.key)
      unique_task_key = unique_keys.get(task.key, task.key)
      if unique_task_key not in all_tasks and unique_obj_key in all_tasks:
        # This is safe, as if task.key was in unique_key, we would have found
        # unique_task_key in all_tasks
        unique_keys[task.key] = unique_obj_key
        v = get_value(task, all_tasks, dependencies, unique_keys, pending_tasks, refkey)
        # Remove it as task.key might be mapped to different obj.key
        unique_keys.pop(task.key)
        return v
    return get_value(task, all_tasks, dependencies, unique_keys, pending_tasks, refkey)
  elif isinstance(obj, Alias):
    target = unique_keys.get(obj.target, obj.target)
    task = None
    if target in dependencies:
      task = dependencies[target]
    else:
      task = all_tasks[target]
    return get_value(task, all_tasks, dependencies, unique_keys, pending_tasks, refkey)
  elif isinstance(obj, Task):
    key = unique_keys.get(obj.key, obj.key)
    if key in all_tasks:
      return GeneratedValue(str(key))
    else:
      # Create a new key and later register the new task
      func_name = obj.func.__name__
      new_key = make_unique_key(refkey, f'{func_name}-{uuid4()}')
      if obj.key is not None:
        unique_keys[obj.key] = new_key
      new_task = Task(new_key, obj.func, *obj.args, **obj.kwargs)
      pending_tasks.append((new_key, new_task))
      return GeneratedValue(str(new_key))
  elif isinstance(obj, DataNode):
    if obj.key in all_tasks:
      return ReadyValue(str(obj.key), obj.value)
    else:
      return RawValue(obj.value)
  else:
    return RawValue(obj)

def get_values_from_list(
  obj: Any, items: set, all_tasks: dict[Key, Task | DataNode],
  dependencies: dict[Key, Task | DataNode | Alias | Any],
  unique_keys: dict[Key, Key],
  pending_tasks: list[tuple[Key, Task]],
  refkey: Key
):
  """Recursively takes all items from a list and its sublists. See get_value for
  additional information about the parameters."""

  if isinstance(obj, List):
    for item in obj:
      get_values_from_list(item, items, all_tasks, dependencies, unique_keys, pending_tasks, refkey)
  else:
    items.add(get_value(obj, all_tasks, dependencies, unique_keys, pending_tasks, refkey))

def make_unique_key(parent: Key, child: Key) -> Key:
  """Takes the key of a task `child` which has been started by `parent`, i.e.
  child is part of the `inner_dsk` dictionary of `parent.args`. If `child` is
  a non-unique key, returns a new key that embeds `parent`'s info to produce
  a new unique key."""

  key = child
  # This first condition should always be True
  if isinstance(parent, tuple) and len(parent) > 1:
    if isinstance(child, tuple) and len(child) == 1:
      key = (child[0], *parent[1:])
    elif not isinstance(child, tuple):
      key = (child, *parent[1:])
    # Otherwise, the child key is fine as it is
  return key

def are_equal_keys(key1: Key, key2: Key) -> bool:
  """Checks if `key1` and `key2` has the same str-part of the key, i.e. they
  might be keys pointing to the same resource, but one doesn't have the indeces
  used to distinguish operations on different chunks."""

  str1 = key1
  if isinstance(key1, tuple):
    str1 = key1[0]
  str2 = key2
  if isinstance(key2, tuple):
    str2 = key2[0]
  return str1 == str2
