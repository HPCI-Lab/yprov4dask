from dask.task_spec import Task, Alias
from dask.typing import Key
from distributed.scheduler import TaskState

from collections.abc import Callable
from typing import Any
import inspect

class RunnableTaskInfo:
  """Container for all task info that will have to be registered in the
  provenance document"""

  def __init__(self, task: TaskState):
    self.key: Key = task.key
    specs: Task = task.run_spec
    self.func: Callable = specs.func
    self.group: str = task.group_key
    self.dependencies: list[str] = []
    for dep in task.dependencies:
      # This is to avoid registering non-runnable tasks, registered as entities,
      # as informant activities of this task since that would be inconsistent
      # with the W3C Prov data model
      if isinstance(dep.run_spec, Task):
        self.dependencies.append(dep.key)
    self.start_time = None
    self.finish_time = None

    self.args_dict: dict[str, ReadyValue | GeneratedValue] = {}
    param_names = list(inspect.signature(self.func).parameters)
    for name, value in zip(param_names, specs.args):
      if isinstance(value, Alias):
        self.args_dict[name] = GeneratedValue(value.target)
      else:
        self.args_dict[name] = ReadyValue(value)
    for name, value in specs.kwargs.items():
      if isinstance(value, Alias):
        self.args_dict[name] = GeneratedValue(value.target)
      else:
        self.args_dict[name] = ReadyValue(value)


class ReadyValue:
  """A value already available to the task"""

  def __init__(self, value: Any):
    self.value = value

class GeneratedValue:
  """A value which has been generated by another task"""

  def __init__(self, generator: str):
    self.generatedBy = generator