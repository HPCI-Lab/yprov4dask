from dask.typing import Key
import datetime as dt
from distributed.scheduler import TaskState
import prov.model as prov

def sanitize(string: str):
  return string.replace('(', '').replace(')', '').replace('\'', '').replace(', ', '_')
  return string

def serialize_value(obj):
  if isinstance(obj, (int, float, complex, bool, type(None))):
    return obj
  elif isinstance(obj, (list, tuple)):
    tmp_list = [ serialize_value(x) for x in obj ]
    if isinstance(obj, tuple):
      return tuple(tmp_list)
    else:
      return tmp_list
  elif isinstance(obj, dict):
    return { k: serialize_value(v) for k, v in obj.items() }
  else:
    return str(obj)

class Documenter:
  def __init__(self, **kwargs):
    self.document = prov.ProvDocument()
    self.document.set_default_namespace('dask-prov.dict')
    self.format = kwargs.get('format')
    self.destination = kwargs.get('destination')
    self.kwargs = kwargs
  
  def register_function_call(
    self, task_id: str, func_name: str, func_module: str,
    func_args: dict[str, any], group: str, depts: set[TaskState]
  ) -> (Key, list[str]):
    """
    Registers in the provenance document a function call, i.e. a new activity is
    created and it is linked with its arguments through a `used` relation.
    An entity for each argument is also created.
    """
    parameters = []
    
    task_id = sanitize(task_id)
    self.document.activity(
      identifier=task_id,
      startTime=dt.datetime.now(),
      other_attributes={
        'name': func_name,
        'module': func_module,
        'group': group
      }
    )

    for arg, value in func_args.items():
      name = f'{task_id}.{arg}'
      parameters.append(name)
      s = str(serialize_value(value))
      self.document.entity(
        identifier=name,
        other_attributes={
          'value': s,
          'dtype': type(value).__qualname__
        }
      )
      self.document.used(task_id, entity=name)

    for task in depts:
      key = sanitize(str(task.key))
      self.document.wasInformedBy(informed=task_id, informant=key)
    
    return (task_id, parameters)

  def register_function_result(
    self, task_id: str, dtype: any, nbytes: int
  ):
    """
    Registers in the provenance document the completion of a function call, i.e.
    the return value of that function is registered as a new entity generated by
    the completed activity. An entity for the produced value is created, while
    the activity should already be present.
    """
    task_id = sanitize(task_id)
    name = f'{task_id}.return_value'
    self.document.entity(
      identifier=name,
      other_attributes={
        'dtype': dtype,
        'nbyte': str(nbytes)
      }
    )
    now = dt.datetime.now()
    self.document.wasGeneratedBy(entity=name, activity=task_id, time=now)

  def register_function_error(
    self, task_id: str, exception_text: str, stacktrace: str | None,
    blamed_task: TaskState | None
  ):
    task_id = sanitize(task_id)
    name = f'{task_id}.return_value'
    attributes = {
      'is_error': True,
      'exception_text': exception_text,
    }
    if stacktrace is not None:
      attributes.setdefault('stacktrace', stacktrace)

    if blamed_task is not None and blamed_task.key != task_id:
      other_task_id = sanitize(str(blamed_task.key))
      attributed.setdefault('blamed_task', other_task_id)
      self.document.wasInformedBy(informed=task_id, informant=other_task_id)

    self.document.entity(
      identifier=name,
      other_attributes=attributes
    )
    self.document.wasGeneratedBy(entity=name, activity=task_id, time=dt.datetime.now())

  def serialize(self, destination, format: str | None, **kwargs: dict[str, any]):
    if format is None and self.format is not None:
      format = self.format
    if destination is None and self.destination is not None:
      destination = self.destination

    return self.document.serialize(
      destination=destination, format=format, **kwargs
    )
